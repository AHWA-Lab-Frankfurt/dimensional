---
title: "dimensional"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dimensional}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dimensional)
library(tidygraph)
library(igraph)
library(tidyverse)
```
# How to use the package:
## Data:
Dimensional takes data in a table graph format. This can be added a number of ways, for details see https://www.data-imaginist.com/2017/introducing-tidygraph/. For an example, we will here use an edgelist and a nodelist to create an undirected table graph.
```{r make tbl-graph}
data("nodes_decor", "edges_decor")
decor.graph <- tbl_graph(nodes = nodes_decor, edges = edges_decor, directed = FALSE)

decor.graph
```
In this example data, the different dimensions of the graph are stored as edge attributes under the `name` variable. You should make sure that your data also stores the dimensions this way, and be certain to call this variable "name".

## `flatten()`
This function flattens a multilayer graph into a simple graph. This function is useful for comparing multilayer with simple network measures. 
`flatten()`simply collapses all edges between a pair of actors across all layers into a single edge. If there is a weight column, the weights of all collapsed edges will be summed. If weight = NULL, no weights are retained. 
```{r}
simple.flat <- flatten(decor.graph, weighted = FALSE)

simple.flat

weighted.flat <- flatten(decor.graph, weighted = TRUE)

weighted.flat
```
## `multidesc()`: 
This function will give a particular set of measures for a basic description of a multilayer network, both layer by layer and for the flattened network. The measures are: number of nodes, density, clustering coefficient, degree centralization, average path length, diameter.
```{r multidesc}
# multidesc(decor.graph)
```

## `centrality_neighborhood()`
This augments the `centrality_` classes in tidygraph with neighborhood centrality as defined by Berlingerio et al. (2011). `centrality_neighborhood()` can take a specified actor, or a vector of actors, as well as a specified layer of vector of layers. If these are left unspecified, it defaults to the entire graph. The function appends a neighborhood centrality measure as a node attribute named "neighbours"
```{r centrality_neighborhood}
a <- c("5", "6")  #specify actors by id
l <- c("folded_strip_roulette")

centrality_neighborhood(decor.graph)

```
## `connective_redundancy()``
Calculates the connective redundancy of a set of actors over a set of layers as defined by Dickison et al. (2016). Can take a specified actor, or a vector of actors, as well as a specified layer of vector of layers. If these are left unspecified, it defaults to the entire graph. Returns a tibble with actor name, degree, neighbors, and redundancy.
```{r connective redundancy}
conred <- connective_redundancy(decor.graph)

head(conred)
```

## `dimensional_correlation_node()``
Calculates the correlation between dimensions based on the neighborhood centrality of the nodes in each layer as defined by Dickison et al. (2016). The neighborhood centrality can be weighted. By default it is unweighted. The output is a correlation matrix of the dimensions.
```{r}
dimension.correlation.node <- dimension_correlation_node(decor.graph, dimensions = name) 


#plotting a heatmap for the correlation matrix
dimension.correlation.node[lower.tri(dimension.correlation.node, diag = TRUE)] <- NA
cor_tri <- as.data.frame(dimension.correlation.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.pvalue.node <- dimension_correlation_node(decor.graph, dimensions = name, pvalue = TRUE)[[2]] 


#plotting a heatmap for the correlation matrix
dimension.pvalue.node[lower.tri(dimension.pvalue.node, diag = TRUE)] <- NA
pv_tri <- as.data.frame(dimension.pvalue.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) %>% 
  mutate(robustness = case_when(value < 0.05 ~ "p-value < 0.05", TRUE ~ "p-value > 0.05"))

ggplot(data = pv_tri, aes(Var2, Var1, fill = robustness)) + 
  geom_tile()+
 scale_fill_manual(values = c("green", "red"))+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.correlation.node <- dimension_correlation_node(decor.graph, dimensions = name, weight = TRUE) 


#plotting a heatmap for the correlation matrix
dimension.correlation.node[lower.tri(dimension.correlation.node, diag = TRUE)] <- NA
cor_tri <- as.data.frame(dimension.correlation.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.pvalue.node <- dimension_correlation_node(decor.graph, dimensions = name, weight = TRUE, pvalue = TRUE)[[2]] 


#plotting a heatmap for the correlation matrix
dimension.pvalue.node[lower.tri(dimension.pvalue.node, diag = TRUE)] <- NA
pv_tri <- as.data.frame(dimension.pvalue.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) %>% 
  mutate(robustness = case_when(value < 0.05 ~ "p-value < 0.05", TRUE ~ "p-value > 0.05"))

ggplot(data = pv_tri, aes(Var2, Var1, fill = robustness)) + 
  geom_tile()+
 scale_fill_manual(values = c("green", "red"))+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

#pvalues can be taken from the matrix to get the exact value
paste("pvalue straight_cord_mat& braided_strip_roulette", dimension.pvalue.node["straight_cord_mat", "braided_strip_roulette"])

```

