---
title: "dimensional"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dimensional}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dimensional)
library(tidygraph)
library(tidyverse)
library(ggraph)
library(igraph)
```
# How to use the package:
## Data:
Dimensional takes data in a table graph format. This can be added a number of ways, for details see https://www.data-imaginist.com/2017/introducing-tidygraph/. For an example, we will here use an edgelist and a nodelist to create an undirected table graph.
```{r make tbl-graph}
decor.graph <- tbl_graph(nodes = nodes_decor, edges = edges_decor, directed = FALSE)

decor.graph
```
In this example data, the different dimensions of the graph are stored as edge attributes under the `name` variable. You should make sure that your data also stores the dimensions this way, and be certain to call this variable "name".

## `flatten()`
This function flattens a multilayer graph into a simple graph. This function is useful for comparing multilayer with simple network measures. 
`flatten()`simply collapses all edges between a pair of actors across all layers into a single edge. If there is a weight column, the weights of all collapsed edges will be summed. If weight = NULL, no weights are retained. 
```{r}
simple.flat <- flatten(decor.graph, weight = NULL)

simple.flat

weighted.flat <- flatten(decor.graph, weight = weight)

weighted.flat
```
## `multidesc()`: 
This function will give a particular set of measures for a basic description of a multilayer network, both layer by layer and for the flattened network. The measures are: number of nodes, density, clustering coefficient, degree centralization, average path length, diameter.
```{r multidesc}
multidesc(decor.graph)
```

## `centrality_neighborhood()`
This augments the `centrality_` classes in tidygraph with neighborhood centrality as defined by Berlingerio et al. (2011). `centrality_neighborhood()` can take a specified actor, or a vector of actors, as well as a specified layer of vector of layers. If these are left unspecified, it defaults to the entire graph. The neighbors can also be weighted. By default it is unweighted. The function appends a neighborhood centrality measure as a node attribute named "neighbours". The output is a vector that can be added to the node list.
```{r centrality_neighborhood}
a <- c("5", "6")  #specify actors by id
l <- c("folded_strip_roulette")

centrality_neighborhood(decor.graph)

decor.graph %>% 
  activate(nodes) %>% 
  mutate(deg = centrality_neighborhood(., weighted = TRUE)) %>% 
#not perfect as it doesnt work without the "."
  ggraph(layout = "stress") +
  geom_edge_fan(aes(col = name))+
  geom_node_point(aes(size = deg))
```
## `connective_redundancy()``
Calculates the connective redundancy of a set of actors over a set of layers as defined by Dickison et al. (2016). Can take a specified actor, or a vector of actors, as well as a specified layer of vector of layers. If these are left unspecified, it defaults to the entire graph. Returns a tibble with actor name, degree, neighbors, and redundancy.
```{r connective redundancy}
conred <- connective_redundancy(decor.graph)

head(conred)
```

## `dimension_relevance()``
Calculates the relevance of each layer for each node as defined by Berlingerio et al. (2011). The neighborhood centrality of the layer is divided by the neighborhood centrality of the flattened network. The neighborhood centrality can be weighted. By default it is unweighted. It returns a dataframe with the dimension relevance of each layer on each node aswell as a row with the mean dimension relevance for the whole graph.
```{r}
dimension_relevance(decor.graph, weighted = TRUE)

dimheat <- decor.graph %>% 
  dimension_relevance() %>% 
 # mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  select(-id, -neighbor) %>% 
  filter(label != "mean") %>% 
  gather(key = "decor", value = "dimension_relevance", -label, na.rm = TRUE) 

ggplot(data = dimheat, aes(decor, label, fill = dimension_relevance)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

