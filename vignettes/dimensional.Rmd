---
title: "dimensional"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dimensional}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dimensional)
library(tidygraph)
library(tidyverse)

```
# How to use the package:
## Data:
Dimensional takes data in a table graph format. This can be added a number of ways, for details see https://www.data-imaginist.com/2017/introducing-tidygraph/. For an example, we will here use an edgelist and a nodelist to create an undirected table graph.
```{r make tbl-graph}

data("nodes_decor", "edges_decor")
decor.graph <- tbl_graph(nodes = nodes_decor, edges = edges_decor, directed = FALSE)


decor.graph
```
In this example data, the different dimensions of the graph are stored as edge attributes under the `name` variable. You should make sure that your data also stores the dimensions this way, and be certain to call this variable "name".

## `flatten()`
This function flattens a multilayer graph into a simple graph. This function is useful for comparing multilayer with simple network measures. 
`flatten()`simply collapses all edges between a pair of actors across all layers into a single edge. If there is a weight column, the weights of all collapsed edges will be summed. If weight = NULL, no weights are retained. 
```{r}
simple.flat <- flatten(decor.graph, weighted = FALSE)

simple.flat

weighted.flat <- flatten(decor.graph, weighted = TRUE)

weighted.flat
```
## `multidesc()`: 
This function will give a particular set of measures for a basic description of a multilayer network, both layer by layer and for the flattened network. The measures are: number of nodes, density, clustering coefficient, degree centralization, average path length, diameter.
```{r multidesc}
# multidesc(decor.graph)
```

## `centrality_neighborhood()`
This augments the `centrality_` classes in tidygraph with neighborhood centrality as defined by Berlingerio et al. (2011). `centrality_neighborhood()` can take a specified actor, or a vector of actors, as well as a specified layer of vector of layers. If these are left unspecified, it defaults to the entire graph. The function appends a neighborhood centrality measure as a node attribute named "neighbours"
```{r centrality_neighborhood}
a <- c("5", "6")  #specify actors by id
l <- c("folded_strip_roulette")

centrality_neighborhood(decor.graph)

```

## `connective_redundancy()``
Calculates the connective redundancy of a set of actors over a set of layers as defined by Dickison et al. (2016). Can take a specified actor, or a vector of actors, as well as a specified layer of vector of layers. If these are left unspecified, it defaults to the entire graph. Returns a tibble with actor name, degree, neighbors, and redundancy.
```{r connective redundancy}
conred <- connective_redundancy(decor.graph)

head(conred)
```


## `dimension_relevance()``
Calculates the relevance of each layer for each node as defined by Berlingerio et al. (2011). The neighborhood centrality of the layer is divided by the neighborhood centrality of the flattened network. The neighborhood centrality can be weighted. By default it is unweighted. It returns a dataframe with the dimension relevance of each layer on each node aswell as a row with the mean dimension relevance for the whole graph.
```{r}
dimension_relevance(decor.graph, dimensions = name, weighted = TRUE)
dimension_relevance(decor.graph, dimensions = name)


dimheat <- decor.graph %>% 
  dimension_relevance(dimensions = name) %>% 
 # mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  select(-id, -neighbor) %>% 
  filter(label != "mean") %>% 
  gather(key = "decor", value = "dimension_relevance", -label, na.rm = TRUE) 

ggplot(data = dimheat, aes(decor, label, fill = dimension_relevance)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```



## `dimension_matlist()``
Calculates the adjacency matrices of the dimensions of a chosen aspect. The adjacency matrices can be based on weighted edges. By default the edges are unweighted and output is a list of correlation matrices of the dimensions. 
```{r}
cor.matlist.w <- dimension_matlist(decor.graph, dimensions = "name", weighted = TRUE) 

cor.matlist <- dimension_matlist(decor.graph, dimensions = "name") 
cor.matlist[[1]]
cor.matlist.w[["straight_cord_mat"]]

cor.matlist.a <- dimension_matlist(decor.graph, actors = c(2,4:6,14,18:19), dimensions = "name") 

```


## `dimensional_correlation()``
Calculates the correlation between dimensions based on the QAP (Krackhardt 1988) of the adjacency matrices of the dimensions as defined by Dickison et al. (2016). The adjacency matrices can be based on weighted edges. By default the edges are unweighted and output is a correlation matrix of the dimensions. If needed the output can be turned into a list also containing a matrix of the p-values of each correlation (on second position of the list). This can be used to check how robust a correlation is that appears do be interesting. 
```{r}

dimension.correlation.w <- dimension_correlation(cor.matlist.w)
#plotting a heatmap for the correlation matrix
dimension.correlation.w[lower.tri(dimension.correlation.w, diag = TRUE)] <- NA
cor_tri.w <- as.data.frame(dimension.correlation.w) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri.w, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.pv.w <- dimension_correlation(cor.matlist.w, pvalue = TRUE)[[2]]
#plotting a heatmap for the correlation matrix
dimension.pv.w[lower.tri(dimension.pv.w, diag = TRUE)] <- NA
pv_tri.w <- as.data.frame(dimension.pv.w) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) %>% 
  mutate(robustness = case_when(value < 0.05 ~ "p-value < 0.05", TRUE ~ "p-value > 0.05"))

ggplot(pv_tri.w, aes(Var2, Var1, fill = robustness)) + 
  geom_tile()+
 scale_fill_manual(values = c("green", "red"))+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))



dimension.correlation <- dimension_correlation(cor.matlist, pvalue = TRUE)[[1]]
#plotting a heatmap for the correlation matrix
dimension.correlation[lower.tri(dimension.correlation, diag = TRUE)] <- NA
cor_tri <- as.data.frame(dimension.correlation) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.pv <- dimension_correlation(cor.matlist, pvalue = TRUE)[[2]]
#plotting a heatmap for the correlation matrix
dimension.pv[lower.tri(dimension.pv, diag = TRUE)] <- NA
pv_tri <- as.data.frame(dimension.pv) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) %>% 
  mutate(robustness = case_when(value < 0.05 ~ "p-value < 0.05", TRUE ~ "p-value > 0.05"))

ggplot(pv_tri, aes(Var2, Var1, fill = robustness)) + 
  geom_tile()+
 scale_fill_manual(values = c("green", "red"))+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))



dimension.correlation <- dimension_correlation(cor.matlist.a, pvalue = TRUE)[[1]]
#plotting a heatmap for the correlation matrix
dimension.correlation[lower.tri(dimension.correlation, diag = TRUE)] <- NA
cor_tri <- as.data.frame(dimension.correlation) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

## `dimensional_correlation_node()``
Calculates the correlation between dimensions based on the neighborhood centrality of the nodes in each layer as defined by Dickison et al. (2016). The neighborhood centrality can be weighted. By default it is unweighted. The output is a correlation matrix of the dimensions.
```{r}
dimension.correlation.node <- dimension_correlation_node(decor.graph, dimensions = name) 


#plotting a heatmap for the correlation matrix
dimension.correlation.node[lower.tri(dimension.correlation.node, diag = TRUE)] <- NA
cor_tri <- as.data.frame(dimension.correlation.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.pvalue.node <- dimension_correlation_node(decor.graph, dimensions = name, pvalue = TRUE)[[2]] 


#plotting a heatmap for the correlation matrix
dimension.pvalue.node[lower.tri(dimension.pvalue.node, diag = TRUE)] <- NA
pv_tri <- as.data.frame(dimension.pvalue.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) %>% 
  mutate(robustness = case_when(value < 0.05 ~ "p-value < 0.05", TRUE ~ "p-value > 0.05"))

ggplot(data = pv_tri, aes(Var2, Var1, fill = robustness)) + 
  geom_tile()+
 scale_fill_manual(values = c("green", "red"))+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.correlation.node <- dimension_correlation_node(decor.graph, dimensions = name, weight = TRUE) 


#plotting a heatmap for the correlation matrix
dimension.correlation.node[lower.tri(dimension.correlation.node, diag = TRUE)] <- NA
cor_tri <- as.data.frame(dimension.correlation.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) 

ggplot(data = cor_tri, aes(Var2, Var1, fill = value)) + 
  geom_tile()+
 scale_fill_viridis_c()+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

dimension.pvalue.node <- dimension_correlation_node(decor.graph, dimensions = name, weight = TRUE, pvalue = TRUE)[[2]] 


#plotting a heatmap for the correlation matrix
dimension.pvalue.node[lower.tri(dimension.pvalue.node, diag = TRUE)] <- NA
pv_tri <- as.data.frame(dimension.pvalue.node) %>% 
  mutate(Var1 = factor(row.names(.), levels=row.names(.))) %>% 
  gather(key = Var2, value = value, -Var1, na.rm = TRUE, factor_key = TRUE) %>% 
  mutate(robustness = case_when(value < 0.05 ~ "p-value < 0.05", TRUE ~ "p-value > 0.05"))

ggplot(data = pv_tri, aes(Var2, Var1, fill = robustness)) + 
  geom_tile()+
 scale_fill_manual(values = c("green", "red"))+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

#pvalues can be taken from the matrix to get the exact value
paste("pvalue straight_cord_mat& braided_strip_roulette", dimension.pvalue.node["straight_cord_mat", "braided_strip_roulette"])

```

